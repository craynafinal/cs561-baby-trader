*********세일 완료시 아기 삭제, 새로운 손님
checkavailability: 중복으로 들어오는 new attribute, (아직 가끔 안바뀔 때가 있음, 앞의 것이 원인)


및 새로운 손님 받기, 아기 삭제, how to play 및 credits


location based on anchor(.5)

light gray bg: afb3b6
dark gray bg: 637079

baby: 375x217
customer: 109x201


below is location based on 0,0

template
-customer text: 27x363
-money to make: 461x471 (right top)
-time: 572x471 (right top)
-baby text(d4dbe1): name(520x36 / size: 27)
	description(520x65 / size: 18)
	properties(519x137 / size: 14)

-energybar(245x553 / size: 190x18)

below is location based on 1, 0(right top)

begin
-time given: 564 x 246 (right top)
-sales goal: 564 x 312 (right top)

result
-time taken: 565x215
-total sales: 564x281
-sales goal: 564x347

green txt:25px, 35eb35















                        /*
                        var randomAttribute = new BabyTrader.Attribute();
                        var checkRandom = false;

                        while (!checkRandom) {
                            if (currentCustomer.checkElementAvailability(randomAttribute) && !attributeArrayContainsTheElement(babyAttributes, randomAttribute)) {
                                // update the attribute
                                babyAttributes[index] = randomAttribute;

                                // update the display
                                BabyTrader.Play.displayBabies(currentObject, currentObject.baby_index);

                                checkRandom = true;
                            } else {
                                randomAttribute = new BabyTrader.Attribute();
                            }
                        }
                        check = true;
                        */



var currentCustomer = currentObject.customers[currentObject.customer_index];
                var currentCustomerAttributes = currentCustomer.getAttributes();
                var babyAttributes = currentObject.babies[currentObject.baby_index].getAttributes();
                var checkReplaceIndex = false;
                var checkTarget = false;
                var index = 0;
                var replaceIndex = -1;

                while (!checkReplaceIndex && !checkTarget && (index < babyAttributes.length - 1)) {

                    // find the element that is not needed, so it can be replaced
                    if (!currentCustomer.checkElementAvailability(babyAttributes[index])) {
                        if (replaceIndex === -1) {
                            replaceIndex = index;
                            checkReplaceIndex = true;
                        }
                    // the attribute already exists
                    } else {
                        //currentCustomerAttributes = currentCustomerAttributes.splice(index, 1);
                        checkTarget = true;
                    }
                    index++;